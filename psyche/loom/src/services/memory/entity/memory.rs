use crate::memory::types::{MemoryFragment, MemorySource, ObjectiveMetadata, SubjectiveMetadata};
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "memory_fragments")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i64,

    #[sea_orm(column_type = "Text")]
    pub content: String,

    #[sea_orm(column_type = "custom(\"DATETIME(6)\")")]
    pub created_at: time::OffsetDateTime,

    #[sea_orm(column_type = "custom(\"DATETIME(6)\")")]
    pub updated_at: time::OffsetDateTime,

    #[sea_orm(column_type = "Text")]
    pub source: String,

    pub importance: i8,  // Changed to tiny_integer to match MemoryFragment's u8
    pub confidence: i8, // Changed to tiny_integer to match MemoryFragment's u8

    #[sea_orm(column_type = "Text")]
    pub tags: String,

    #[sea_orm(column_type = "Text")]
    pub notes: String,

    #[sea_orm(column_type = "Text")]
    pub associations: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl From<MemoryFragment> for Model {
    fn from(memory: MemoryFragment) -> Self {
        Self {
            // ID will be auto-generated by database
            id: 0, // This will be ignored by insert
            content: memory.content,
            created_at: memory.objective_metadata.created_at,
            updated_at: memory.objective_metadata.updated_at,
            source: serde_json::to_string(&memory.objective_metadata.source)
                .expect("MemorySource must be serializable"),
            importance: memory.subjective_metadata.importance as i8,
            confidence: memory.subjective_metadata.confidence as i8,
            tags: serde_json::to_string(&memory.subjective_metadata.tags)
                .expect("Tags must be serializable"),
            notes: memory.subjective_metadata.notes,
            associations: serde_json::to_string(&memory.associations)
                .expect("Associations must be serializable"),
        }
    }
}

impl From<Model> for MemoryFragment {
    fn from(model: Model) -> Self {
        let source: MemorySource = serde_json::from_str(&model.source)
            .expect("Source must be valid MemorySource JSON");

        MemoryFragment {
            id: model.id,
            content: model.content,
            subjective_metadata: SubjectiveMetadata {
                importance: model.importance as u8,
                confidence: model.confidence as u8,
                tags: serde_json::from_str(&model.tags)
                    .expect("Tags must be valid JSON array"),
                notes: model.notes,
            },
            objective_metadata: ObjectiveMetadata {
                created_at: model.created_at,
                updated_at: model.updated_at,
                source,
            },
            associations: serde_json::from_str(&model.associations)
                .expect("Associations must be valid JSON array"),
        }
    }
}
